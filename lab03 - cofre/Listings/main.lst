


ARM Macro Assembler    Page 1 


    1 00000000         ; main.s
    2 00000000         ; Desenvolvido para a placa EK-TM4C1294XL
    3 00000000         
    4 00000000         ; ------------------------------------------------------
                       -------------------------
    5 00000000                 THUMB                        ; Instruções do tip
                                                            o Thumb-2
    6 00000000         ; ------------------------------------------------------
                       -------------------------
    7 00000000         ; Declarações EQU - Defines
    8 00000000         ;<NOME>         EQU <VALOR>
    9 00000000 00007777 
                       MASTER_PW
                               EQU              0x7777
   10 00000000         ; ========================
   11 00000000         
   12 00000000         ; ------------------------------------------------------
                       -------------------------
   13 00000000         ; Área de Dados - Declarações de variáveis
   14 00000000                 AREA             DATA, ALIGN=2
   15 00000000         ; Se alguma variável for chamada em outro arquivo
   16 00000000         ;EXPORT  <var> [DATA,SIZE=<tam>]   ; Permite chamar a va
                       riável <var> a 
   17 00000000         ; partir de outro arquivo
   18 00000000         ;<var> SPACE <tam>                        ; Declara uma 
                       variável de nome <var>
   19 00000000         ; de <tam> bytes a partir da primeira 
   20 00000000         ; posição da RAM 
   21 00000000 00 00   ARRAY_PW
                               SPACE            2           ; (2 bytes) senha d
                                                            o usuario
   22 00000002 00 00   INPUT_PW
                               SPACE            2           ; (2 bytes) senha a
                                                            uxiliar
   23 00000004 00      NUM_ATTEMPTS
                               SPACE            1           ; (1 byte) numero d
                                                            e tentativas
   24 00000005 00      IS_LOCKED
                               SPACE            1           ; (1 byte) define s
                                                            e cofre esta travad
                                                            o ou nao
   25 00000006         
   26 00000006         ; ------------------------------------------------------
                       -------------------------
   27 00000006         ; Área de Código - Tudo abaixo da diretiva a seguir será
                        armazenado na memória de 
   28 00000006         ;                  código
   29 00000006                 AREA             |.text|, CODE, READONLY, ALIGN=
2
   30 00000000         
   31 00000000         ; Se alguma função do arquivo for chamada em outro arqui
                       vo 
   32 00000000                 EXPORT           Start       ; Permite chamar a 
                                                            função Start a part
                                                            ir de 
   33 00000000         ; outro arquivo. No caso startup.s
   34 00000000         
   35 00000000                 EXPORT           IS_LOCKED[DATA,SIZE=1] ; export
                                                            a para tratamento d



ARM Macro Assembler    Page 2 


                                                            a interrupcao
   36 00000000         
   37 00000000         ; Se chamar alguma função externa 
   38 00000000         ;IMPORT <func>              ; Permite chamar dentro dest
                       e arquivo uma 
   39 00000000         ; função <func>
   40 00000000                 IMPORT           PLL_Init
   41 00000000                 IMPORT           SysTick_Init
   42 00000000                 IMPORT           SysTick_Wait1ms
   43 00000000                 IMPORT           SysTick_Wait1us
   44 00000000         
   45 00000000                 IMPORT           SW1_SW2_init
   46 00000000         
   47 00000000                 IMPORT           LCD_init
   48 00000000                 IMPORT           LCD_reset
   49 00000000                 IMPORT           LCD_command
   50 00000000                 IMPORT           LCD_write_data
   51 00000000                 IMPORT           LCD_print_string
   52 00000000         
   53 00000000                 IMPORT           MKBOARD_init
   54 00000000                 IMPORT           MKBOARD_getValuePressed
   55 00000000                 IMPORT           MKBOARD_valueToASCII
   56 00000000         
   57 00000000                 IMPORT           LEDS_AND_DISPLAYS_init
   58 00000000                 IMPORT           select_leds
   59 00000000                 IMPORT           select_dig_DS
   60 00000000                 IMPORT           turn_leds_ON
   61 00000000                 IMPORT           turn_DS1_ON
   62 00000000                 IMPORT           turn_DS2_ON
   63 00000000         
   64 00000000         ; ------------------------------------------------------
                       -------------------------
   65 00000000         ; Função main()    
   66 00000000         Start
   67 00000000 F7FF FFFE       BL               PLL_Init    ;altera o clock do 
                                                            microcontrolador pa
                                                            ra 80MHz
   68 00000004 F7FF FFFE       BL               SysTick_Init ;inicializa timer 
                                                            para delay
   69 00000008 F7FF FFFE       BL               LCD_init    ;inicializa LCD
   70 0000000C F7FF FFFE       BL               MKBOARD_init ;inicializa matrix
                                                             keyboard
   71 00000010 F7FF FFFE       BL               LEDS_AND_DISPLAYS_init ;inicial
                                                            iza leds e displays
                                                             da placa TIVA
   72 00000014 F7FF FFFE       BL               SW1_SW2_init ;inicializa SW1 e 
                                                            SW2 nativo da placa
                                                            
   73 00000018         
   74 00000018         ; leitura e escrita em variavel de 1 byte
   75 00000018 481E            LDR              R0, =IS_LOCKED
   76 0000001A F04F 0100       MOV              R1, #0
   77 0000001E 7001            STRB             R1, [R0]
   78 00000020         
   79 00000020         ; leitura e escrita em variavel de 2 bytes
   80 00000020 481D            LDR              R0, =ARRAY_PW
   81 00000022 F64A 31CD       MOV              R1, #0xABCD
   82 00000026 8001            STRH             R1, [R0]
   83 00000028         



ARM Macro Assembler    Page 3 


   84 00000028         loop_principal
   85 00000028 BF00            NOP
   86 0000002A E7FD            B                loop_principal
   87 0000002C         
   88 0000002C         ; ; Initialize the password length counter
   89 0000002C         ;MainLoop
   90 0000002C         ; BL LCD_reset
   91 0000002C         ; MOV R5, #0
   92 0000002C         ; MOV R4, #0
   93 0000002C         ;; BL DisableInterrupt
   94 0000002C         ;    LDR R0, =MSG_OPEN
   95 0000002C         ;    BL LCD_print_string
   96 0000002C         ;    MOV R0, #0xC0
   97 0000002C         ;    BL LCD_command
   98 0000002C         ;    LDR R0, =MSG_PWscreen
   99 0000002C         ;    BL LCD_print_string
  100 0000002C         
  101 0000002C         ;wait_click_open
  102 0000002C         ;    BL MKBOARD_getValuePressed
  103 0000002C         ;    CMP R0, #0xFF
  104 0000002C         ;    BEQ wait_click_open
  105 0000002C         ;; Check if the pressed key is 'E'
  106 0000002C         ;    CMP R0, #0x0E
  107 0000002C         ;    BNE not_e_key_open
  108 0000002C         ;; Check if the password has 4 digits
  109 0000002C         ;    CMP R4, #4
  110 0000002C         ;    BNE wait_click_open
  111 0000002C         
  112 0000002C         ;Closing
  113 0000002C         ;    BL LCD_reset
  114 0000002C         ; LDR R1, =INPUT_PW ; Source array pointer
  115 0000002C         ;    LDR R2, =ARRAY_PW ; Destination array pointer
  116 0000002C         ;    MOV R3, #5 ; Size of the array to copy (4 digits + 
                       null-terminator)
  117 0000002C         ;    BL copy_array ; Call the copy_array function
  118 0000002C         ;    LDR R1, =INPUT_PW ; Array pointer
  119 0000002C         ;    MOV R2, #5 ; Size of the array to clear (4 digits +
                        null-terminator)
  120 0000002C         ; BL clear_array
  121 0000002C         ; LDR R0, =MSG_CLOSING
  122 0000002C         ;    BL LCD_print_string
  123 0000002C         ;    MOV R0, #0xC0
  124 0000002C         ;    BL LCD_command
  125 0000002C         ;    LDR R0, =MSG_PWscreen
  126 0000002C         ;    BL LCD_print_string
  127 0000002C         ;    LDR R1, =ARRAY_PW
  128 0000002C         ;    MOV R2, #0
  129 0000002C         ;display_password_loop
  130 0000002C         ;    LDRB R0, [R1]
  131 0000002C         ;    BL MKBOARD_valueToASCII
  132 0000002C         ;    BL LCD_write_data
  133 0000002C         ;    ADD R1, R1, #1
  134 0000002C         ;    ADD R2, R2, #1
  135 0000002C         ;    CMP R2, #4
  136 0000002C         ;    BLT display_password_loop
  137 0000002C         ;; Add appropriate delay subroutine to pause the display
                        for 5 seconds
  138 0000002C         ;    LDR R0, =5000
  139 0000002C         ;    BL SysTick_Wait1ms



ARM Macro Assembler    Page 4 


  140 0000002C         ; BL Closed
  141 0000002C         
  142 0000002C         ;Closed
  143 0000002C         ;    BL LCD_reset
  144 0000002C         ;    LDR R0, =MSG_CLOSED
  145 0000002C         ;    BL LCD_print_string
  146 0000002C         ; MOV R0, #0xC0
  147 0000002C         ;    BL LCD_command
  148 0000002C         ;    LDR R0, =MSG_PWscreen
  149 0000002C         ;    BL LCD_print_string
  150 0000002C         ; MOV R4, #0
  151 0000002C         ; LDR R1, =INPUT_PW ; Array pointer
  152 0000002C         ;    MOV R2, #5 ; Size of the array to clear (4 digits +
                        null-terminator)
  153 0000002C         ; BL clear_array
  154 0000002C         ;wait_click_closed
  155 0000002C         ;    BL MKBOARD_getValuePressed
  156 0000002C         ;    CMP R0, #0xFF
  157 0000002C         ;    BEQ wait_click_closed
  158 0000002C         ;; Check if the pressed key is 'E'
  159 0000002C         ;    CMP R0, #0x0E
  160 0000002C         ;    BNE not_e_key_closed
  161 0000002C         ;; Check if the password has 4 digits
  162 0000002C         ;    CMP R4, #4
  163 0000002C         ;    BNE wait_click_closed
  164 0000002C         ;; If 'E' is pressed and the password has 4 digits, stor
                       e the password and display MSG_CLOSING
  165 0000002C         ;Password_Check
  166 0000002C         ; ; Call the compare_arrays function
  167 0000002C         ; LDR R1, =INPUT_PW ; Pointer to the first array (INPUT_
                       PW)
  168 0000002C         ; LDR R2, =ARRAY_PW ; Pointer to the second array (ARRAY
                       _PW)
  169 0000002C         ; MOV R3, #4 ; Size of the arrays to compare (4 in your 
                       case)
  170 0000002C         ; BL compare_arrays ; Call the function
  171 0000002C         ; ; Check the result in R0
  172 0000002C         ; CMP R0, #1
  173 0000002C         ; BEQ Opening
  174 0000002C         ; BNE attempt_count
  175 0000002C         
  176 0000002C         ;; Display MSG_CLOSED
  177 0000002C         ;not_e_key_open
  178 0000002C         ;; Check if the password already has 4 digits
  179 0000002C         ;    CMP R4, #4
  180 0000002C         ;    BEQ wait_click_open
  181 0000002C         ;; Store the pressed key value in ARRAY_PW
  182 0000002C         ;    LDR R1, =INPUT_PW
  183 0000002C         ;    ADD R1, R1, R4
  184 0000002C         ;    STR R0, [R1]
  185 0000002C         ;; Increment the password length counter
  186 0000002C         ;    ADD R4, R4, #1
  187 0000002C         ;; Check if the password length counter is now 4
  188 0000002C         ;    CMP R4, #5
  189 0000002C         ;    BNE not_final_digit_open
  190 0000002C         ;; If the password length counter is now 4, null-termina
                       te the ARRAY_PW string
  191 0000002C         ;    ADD R1, R1, #1
  192 0000002C         ;    MOV R0, #0



ARM Macro Assembler    Page 5 


  193 0000002C         ;    STR R0, [R1]
  194 0000002C         ;not_final_digit_open
  195 0000002C         ;; Convert the value to ASCII and display it
  196 0000002C         ;    BL MKBOARD_valueToASCII
  197 0000002C         ;    BL LCD_write_data
  198 0000002C         ;    B wait_click_open
  199 0000002C         
  200 0000002C         ;not_e_key_closed
  201 0000002C         ;; Check if the password already has 4 digits
  202 0000002C         ;    CMP R4, #4
  203 0000002C         ;    BEQ wait_click_closed
  204 0000002C         ;; Store the pressed key value in ARRAY_PW
  205 0000002C         ;    LDR R1, =INPUT_PW
  206 0000002C         ;    ADD R1, R1, R4
  207 0000002C         ;    STR R0, [R1]
  208 0000002C         ;; Increment the password length counter
  209 0000002C         ;    ADD R4, R4, #1
  210 0000002C         ;; Check if the password length counter is now 4
  211 0000002C         ;    CMP R4, #5
  212 0000002C         ;    BNE not_final_digit_closed
  213 0000002C         ;; If the password length counter is now 4, null-termina
                       te the ARRAY_PW string
  214 0000002C         ;    ADD R1, R1, #1
  215 0000002C         ;    MOV R0, #0
  216 0000002C         ;    STR R0, [R1]
  217 0000002C         ;not_final_digit_closed
  218 0000002C         ;; Convert the value to ASCII and display it
  219 0000002C         ;    BL MKBOARD_valueToASCII
  220 0000002C         ;    BL LCD_write_data
  221 0000002C         ;    B wait_click_closed
  222 0000002C         ; 
  223 0000002C         ;attempt_count
  224 0000002C         ; ADD R5, R5, #1
  225 0000002C         ; CMP R5, #2
  226 0000002C         ; BEQ Blocked
  227 0000002C         ; BNE attempt_screen
  228 0000002C         
  229 0000002C         ;Opening
  230 0000002C         ;    BL LCD_reset
  231 0000002C         ;    LDR R0, =MSG_OPENING
  232 0000002C         ;    BL LCD_print_string
  233 0000002C         ;    LDR R0, =5000
  234 0000002C         ;    BL SysTick_Wait1ms
  235 0000002C         ; BL MainLoop 
  236 0000002C         ; 
  237 0000002C         ;attempt_screen
  238 0000002C         ; BL LCD_reset
  239 0000002C         ;    LDR R0, =MSG_AttemptScreen
  240 0000002C         ;    BL LCD_print_string
  241 0000002C         ; LDR R0, =3000
  242 0000002C         ;    BL SysTick_Wait1ms
  243 0000002C         ; BL Closed
  244 0000002C         ; 
  245 0000002C         ;Blocked
  246 0000002C         ; BL LCD_reset
  247 0000002C         ;    LDR R0, =MSG_BLOCKED
  248 0000002C         ;    BL LCD_print_string
  249 0000002C         ; BL EnableInterrupt
  250 0000002C         ; MOV R4, #0



ARM Macro Assembler    Page 6 


  251 0000002C         ; LDR R1, =INPUT_PW ; Array pointer
  252 0000002C         ;    MOV R2, #5 ; Size of the array to clear (4 digits +
                        null-terminator)
  253 0000002C         ; BL clear_array
  254 0000002C         
  255 0000002C         ;enter_pw_master_interrupt
  256 0000002C         ; BL LCD_reset
  257 0000002C         ;    LDR R0, =MSG_BLOCKED
  258 0000002C         ;    BL LCD_print_string
  259 0000002C         ; MOV R0, #0xC0
  260 0000002C         ;    BL LCD_command
  261 0000002C         ;    LDR R0, =MSG_PWscreen
  262 0000002C         ; BL LCD_print_string
  263 0000002C         ;wait_click_blocked
  264 0000002C         ;    BL MKBOARD_getValuePressed
  265 0000002C         ;    CMP R0, #0xFF
  266 0000002C         ;    BEQ wait_click_blocked
  267 0000002C         ;; Check if the pressed key is 'E'
  268 0000002C         ;    CMP R0, #0x0E
  269 0000002C         ;    BNE not_e_key_blocked
  270 0000002C         ;; Check if the password has 4 digits
  271 0000002C         ;    CMP R4, #4
  272 0000002C         ;    BNE wait_click_blocked
  273 0000002C         ;Password_Check_master
  274 0000002C         ; ; Call the compare_arrays function
  275 0000002C         ; LDR R1, =INPUT_PW ; Pointer to the first array (INPUT_
                       PW)
  276 0000002C         ; LDR R2, =MASTER_PW ; Pointer to the second array (ARRA
                       Y_PW)
  277 0000002C         ; MOV R3, #4 ; Size of the arrays to compare (4 in your 
                       case)
  278 0000002C         ; BL compare_arrays ; Call the function
  279 0000002C         ; ; Check the result in R0
  280 0000002C         ; CMP R0, #1
  281 0000002C         ; BEQ Opening
  282 0000002C         ; BNE Blocked
  283 0000002C         
  284 0000002C         ;not_e_key_blocked
  285 0000002C         ;; Check if the password already has 4 digits
  286 0000002C         ;    CMP R4, #4
  287 0000002C         ;    BEQ wait_click_blocked
  288 0000002C         ;; Store the pressed key value in ARRAY_PW
  289 0000002C         ;    LDR R1, =INPUT_PW
  290 0000002C         ;    ADD R1, R1, R4
  291 0000002C         ;    STR R0, [R1]
  292 0000002C         ;; Increment the password length counter
  293 0000002C         ;    ADD R4, R4, #1
  294 0000002C         ;; Check if the password length counter is now 4
  295 0000002C         ;    CMP R4, #5
  296 0000002C         ;    BNE not_final_digit_blocked
  297 0000002C         ;; If the password length counter is now 4, null-termina
                       te the ARRAY_PW string
  298 0000002C         ;    ADD R1, R1, #1
  299 0000002C         ;    MOV R0, #0
  300 0000002C         ;    STR R0, [R1]
  301 0000002C         ;not_final_digit_blocked
  302 0000002C         ;; Convert the value to ASCII and display it
  303 0000002C         ;    BL MKBOARD_valueToASCII
  304 0000002C         ;    BL LCD_write_data



ARM Macro Assembler    Page 7 


  305 0000002C         ;    B wait_click_closed
  306 0000002C         
  307 0000002C         ;copy_array
  308 0000002C         ;    PUSH {R1, R2, R3, LR} ; Save the registers
  309 0000002C         
  310 0000002C         ;copy_loop
  311 0000002C         ;    LDRB R0, [R1]  ; Load a byte from the source array
  312 0000002C         ;    STRB R0, [R2]  ; Store the byte in the destination 
                       array
  313 0000002C         ;    ADD R1, R1, #1 ; Increment the source array pointer
                       
  314 0000002C         ;    ADD R2, R2, #1 ; Increment the destination array po
                       inter
  315 0000002C         ;    SUBS R3, R3, #1 ; Decrement the size counter
  316 0000002C         ;    BNE copy_loop  ; If the size counter is not zero, c
                       ontinue copying
  317 0000002C         ;    POP {R1, R2, R3, LR} ; Restore the registers
  318 0000002C         ;    BX LR ; Return to the calling function
  319 0000002C         ; 
  320 0000002C         ;clear_array
  321 0000002C         ;    PUSH {R1, R2, LR} ; Save the registers
  322 0000002C         
  323 0000002C         ;clear_loop
  324 0000002C         ;    MOV R0, #0      ; Load the value 0
  325 0000002C         ;    STRB R0, [R1]   ; Store the value 0 in the array
  326 0000002C         ;    ADD R1, R1, #1  ; Increment the array pointer
  327 0000002C         ;    SUBS R2, R2, #1 ; Decrement the size counter
  328 0000002C         ;    BNE clear_loop  ; If the size counter is not zero, 
                       continue clearing
  329 0000002C         ;    POP {R1, R2, LR} ; Restore the registers
  330 0000002C         ;    BX LR ; Return to the calling function
  331 0000002C         
  332 0000002C         ;; Function to compare two arrays
  333 0000002C         ;; R1 - Pointer to the first array (INPUT_PW)
  334 0000002C         ;; R2 - Pointer to the second array (ARRAY_PW)
  335 0000002C         ;; R3 - Size of the arrays to compare (4 in your case)
  336 0000002C         ;; Returns: R0 = 1 if arrays are equal, R0 = 0 if arrays
                        are not equal
  337 0000002C         
  338 0000002C         ;compare_arrays
  339 0000002C         ;    PUSH {R1, R2, R3, LR} ; Save the registers
  340 0000002C         
  341 0000002C         ;compare_loop
  342 0000002C         ;    LDRB R0, [R1]  ; Load a byte from the first array
  343 0000002C         ;    LDRB R4, [R2]  ; Load a byte from the second array
  344 0000002C         ;    CMP R0, R4     ; Compare the loaded bytes
  345 0000002C         ;    BNE not_equal  ; If the bytes are not equal, jump t
                       o not_equal
  346 0000002C         
  347 0000002C         ;    ADD R1, R1, #1 ; Increment the first array pointer
  348 0000002C         ;    ADD R2, R2, #1 ; Increment the second array pointer
                       
  349 0000002C         ;    SUBS R3, R3, #1 ; Decrement the size counter
  350 0000002C         ;    BNE compare_loop  ; If the size counter is not zero
                       , continue comparing
  351 0000002C         
  352 0000002C         ;    ; Arrays are equal
  353 0000002C         ;    MOV R0, #1
  354 0000002C         ;    B finish_compare



ARM Macro Assembler    Page 8 


  355 0000002C         
  356 0000002C         ;not_equal
  357 0000002C         ;    ; Arrays are not equal
  358 0000002C         ;    MOV R0, #0
  359 0000002C         
  360 0000002C         ;finish_compare
  361 0000002C         ;    POP {R1, R2, R3, LR} ; Restore the registers
  362 0000002C         ;    BX LR ; Return to the calling function
  363 0000002C         
  364 0000002C         ; If 'E' is pressed and the password has 4 digits, store
                        the password and display MSG_CLOSING
  365 0000002C         
  366 0000002C         ; ========================
  367 0000002C         ; Definicoes das strings utilizadas
  368 0000002C 43 6F 66 
              72 65 20 
              41 62 65 
              72 74 6F 
              21 20 20 
              20 00    MSG_OPEN
                               DCB              "Cofre Aberto!   ",0
  369 0000003D 43 6F 66 
              72 65 20 
              41 62 72 
              69 6E 64 
              6F 21 20 
              20 00    MSG_OPENING
                               DCB              "Cofre Abrindo!  ",0
  370 0000004E 43 6F 66 
              72 65 20 
              46 65 63 
              68 61 6E 
              64 6F 2E 
              2E 2E 00 MSG_CLOSING
                               DCB              "Cofre Fechando...",0
  371 00000060 43 6F 66 
              72 65 20 
              46 65 63 
              68 61 64 
              6F 21 20 
              20 00    MSG_CLOSED
                               DCB              "Cofre Fechado!  ",0
  372 00000071 43 6F 66 
              72 65 20 
              54 72 61 
              76 61 64 
              6F 21 20 
              20 00    MSG_BLOCKED
                               DCB              "Cofre Travado!  ",0
  373 00000082 20 50 57 
              3A 00    MSG_PWscreen
                               DCB              " PW:",0
  374 00000087 54 65 6E 
              74 61 74 
              69 76 61 
              20 2D 2D 
              00       MSG_AttemptScreen
                               DCB              "Tentativa --",0
  375 00000094         



ARM Macro Assembler    Page 9 


  376 00000094                 ALIGN                        ;Garante que o fim 
                                                            da seção está alinh
                                                            ada 
  377 00000094                 END                          ;Fim do arquivo
              00000000 
              00000000 
Command Line: --debug --xref --diag_suppress=9931 --cpu=Cortex-M4.fp.sp --depen
d=.\objects\main.d -o.\objects\main.o -IC:\Users\roger\AppData\Local\Arm\Packs\
Keil\TM4C_DFP\1.1.0\Device\Include\TM4C129 --predefine="__EVAL SETA 1" --predef
ine="__UVISION_VERSION SETA 536" --predefine="TM4C1294NCPDT SETA 1" --list=.\li
stings\main.lst main.s



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Relocatable symbols

ARRAY_PW 00000000

Symbol: ARRAY_PW
   Definitions
      At line 21 in file main.s
   Uses
      At line 80 in file main.s
Comment: ARRAY_PW used once
DATA 00000000

Symbol: DATA
   Definitions
      At line 14 in file main.s
   Uses
      None
Comment: DATA unused
INPUT_PW 00000002

Symbol: INPUT_PW
   Definitions
      At line 22 in file main.s
   Uses
      None
Comment: INPUT_PW unused
IS_LOCKED 00000005

Symbol: IS_LOCKED
   Definitions
      At line 24 in file main.s
   Uses
      At line 35 in file main.s
      At line 75 in file main.s

NUM_ATTEMPTS 00000004

Symbol: NUM_ATTEMPTS
   Definitions
      At line 23 in file main.s
   Uses
      None
Comment: NUM_ATTEMPTS unused
5 symbols



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Relocatable symbols

.text 00000000

Symbol: .text
   Definitions
      At line 29 in file main.s
   Uses
      None
Comment: .text unused
MSG_AttemptScreen 00000087

Symbol: MSG_AttemptScreen
   Definitions
      At line 374 in file main.s
   Uses
      None
Comment: MSG_AttemptScreen unused
MSG_BLOCKED 00000071

Symbol: MSG_BLOCKED
   Definitions
      At line 372 in file main.s
   Uses
      None
Comment: MSG_BLOCKED unused
MSG_CLOSED 00000060

Symbol: MSG_CLOSED
   Definitions
      At line 371 in file main.s
   Uses
      None
Comment: MSG_CLOSED unused
MSG_CLOSING 0000004E

Symbol: MSG_CLOSING
   Definitions
      At line 370 in file main.s
   Uses
      None
Comment: MSG_CLOSING unused
MSG_OPEN 0000002C

Symbol: MSG_OPEN
   Definitions
      At line 368 in file main.s
   Uses
      None
Comment: MSG_OPEN unused
MSG_OPENING 0000003D

Symbol: MSG_OPENING
   Definitions
      At line 369 in file main.s
   Uses
      None
Comment: MSG_OPENING unused
MSG_PWscreen 00000082

Symbol: MSG_PWscreen



ARM Macro Assembler    Page 2 Alphabetic symbol ordering
Relocatable symbols

   Definitions
      At line 373 in file main.s
   Uses
      None
Comment: MSG_PWscreen unused
Start 00000000

Symbol: Start
   Definitions
      At line 66 in file main.s
   Uses
      At line 32 in file main.s
Comment: Start used once
loop_principal 00000028

Symbol: loop_principal
   Definitions
      At line 84 in file main.s
   Uses
      At line 86 in file main.s
Comment: loop_principal used once
10 symbols



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
Absolute symbols

MASTER_PW 00007777

Symbol: MASTER_PW
   Definitions
      At line 9 in file main.s
   Uses
      None
Comment: MASTER_PW unused
1 symbol



ARM Macro Assembler    Page 1 Alphabetic symbol ordering
External symbols

LCD_command 00000000

Symbol: LCD_command
   Definitions
      At line 49 in file main.s
   Uses
      None
Comment: LCD_command unused
LCD_init 00000000

Symbol: LCD_init
   Definitions
      At line 47 in file main.s
   Uses
      At line 69 in file main.s
Comment: LCD_init used once
LCD_print_string 00000000

Symbol: LCD_print_string
   Definitions
      At line 51 in file main.s
   Uses
      None
Comment: LCD_print_string unused
LCD_reset 00000000

Symbol: LCD_reset
   Definitions
      At line 48 in file main.s
   Uses
      None
Comment: LCD_reset unused
LCD_write_data 00000000

Symbol: LCD_write_data
   Definitions
      At line 50 in file main.s
   Uses
      None
Comment: LCD_write_data unused
LEDS_AND_DISPLAYS_init 00000000

Symbol: LEDS_AND_DISPLAYS_init
   Definitions
      At line 57 in file main.s
   Uses
      At line 71 in file main.s
Comment: LEDS_AND_DISPLAYS_init used once
MKBOARD_getValuePressed 00000000

Symbol: MKBOARD_getValuePressed
   Definitions
      At line 54 in file main.s
   Uses
      None
Comment: MKBOARD_getValuePressed unused
MKBOARD_init 00000000

Symbol: MKBOARD_init



ARM Macro Assembler    Page 2 Alphabetic symbol ordering
External symbols

   Definitions
      At line 53 in file main.s
   Uses
      At line 70 in file main.s
Comment: MKBOARD_init used once
MKBOARD_valueToASCII 00000000

Symbol: MKBOARD_valueToASCII
   Definitions
      At line 55 in file main.s
   Uses
      None
Comment: MKBOARD_valueToASCII unused
PLL_Init 00000000

Symbol: PLL_Init
   Definitions
      At line 40 in file main.s
   Uses
      At line 67 in file main.s
Comment: PLL_Init used once
SW1_SW2_init 00000000

Symbol: SW1_SW2_init
   Definitions
      At line 45 in file main.s
   Uses
      At line 72 in file main.s
Comment: SW1_SW2_init used once
SysTick_Init 00000000

Symbol: SysTick_Init
   Definitions
      At line 41 in file main.s
   Uses
      At line 68 in file main.s
Comment: SysTick_Init used once
SysTick_Wait1ms 00000000

Symbol: SysTick_Wait1ms
   Definitions
      At line 42 in file main.s
   Uses
      None
Comment: SysTick_Wait1ms unused
SysTick_Wait1us 00000000

Symbol: SysTick_Wait1us
   Definitions
      At line 43 in file main.s
   Uses
      None
Comment: SysTick_Wait1us unused
select_dig_DS 00000000

Symbol: select_dig_DS
   Definitions
      At line 59 in file main.s
   Uses



ARM Macro Assembler    Page 3 Alphabetic symbol ordering
External symbols

      None
Comment: select_dig_DS unused
select_leds 00000000

Symbol: select_leds
   Definitions
      At line 58 in file main.s
   Uses
      None
Comment: select_leds unused
turn_DS1_ON 00000000

Symbol: turn_DS1_ON
   Definitions
      At line 61 in file main.s
   Uses
      None
Comment: turn_DS1_ON unused
turn_DS2_ON 00000000

Symbol: turn_DS2_ON
   Definitions
      At line 62 in file main.s
   Uses
      None
Comment: turn_DS2_ON unused
turn_leds_ON 00000000

Symbol: turn_leds_ON
   Definitions
      At line 60 in file main.s
   Uses
      None
Comment: turn_leds_ON unused
19 symbols
371 symbols in table
